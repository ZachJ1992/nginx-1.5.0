http://www.walu.cc/phpbook/preface.md
1.2  并发控制
     情境: 多个查询需要同时修改同一数据，就会产生并发控制问题。
     分类: 并发读取 、 并发写入

1.2.1   读锁(Read Lock)/写锁(Write Lock)
        读锁也称为共享锁(Shared Lock); 写锁也称为互斥锁(Exclusive Lock).

        某资源上的读锁是共享的，或者说是互补阻塞的。同一时间，多个用户可读取统一资源，而互不干扰。

        写锁是互斥的， 一个写锁会阻塞其他的读锁和写锁， 这事出于安全策略的考虑， 在给定时间里， 只有一个用户能写入资源， 以防止用户在写操作的同时其他用户读取同一资源。

        对数据库来说，随时随地都会发生锁定。 当某一个用户修改某一部分数据时， MySQL会禁止其他用户读取同一数据。 大多数时候，Mysql都是透明的方式实现锁的内部管理。

1.2.2   锁粒度(Lock Granularity)
        一种提高共享资源并发性的方法就是让锁定对象更有选择性。 要记住只锁定部分须修改的数据，而不是所有的资源。 更理想的方式是， 只对要修改的数据片精确加锁。 任何时间，在给定的资源上， 被加锁的数据量越小， 就可以允许更多的并发修改， 只要相互之间互不冲突即可。

        加锁同样也会消耗系统资源。 每一种锁操作， 如获得锁、检查锁是否已解除，以及释放锁等，都会增加系统的开销。 如果系统花费大量时间来管理锁，而不是读写数据，那么系统整体性能可能会因此受到影响。

        所谓锁策略，就是在锁开销和数据安全之间寻求一种平衡， 这种平衡也能影响系统性能。 

        大多数的商业数据库服务器没有提供更多的选择， 通常都是在表上施加行锁(Row-level Locking)， 并提供种种复杂的手段， 在有锁的情况下改善系统的性能。

        在另一方面，MySQL则提供了多种选择。 每种MySQL存储引擎都可以实现独有的锁策略(Locking Policy)或锁粒度(Lock Granularity)。 在存储引擎设计中， 锁管理(Lock Management)是个非常重要的议题。

        将锁粒度调整到某一水平， 也许就能为某种应用目的提供更加的性能， 不过，这也可能使存储引擎又不是和用于其他的用途了。 由于MySQL可以提供多种存储引擎， 所以它不需要一个通用解决方案。 下面介绍两种最重要的锁策略。

        表锁(Table Lock)
        MySQL支持大多数基本的锁策略， 其中开销最小的锁策略是表锁。 将整个表加锁。 当一个用户对表进行写操作(如插入、删除、更新)时， 用户可以获得一个写锁。 写锁会禁止其他任用户的读写操作。 另外， 只有无人做写操作时， 用户才能获得读锁， 读锁之间是互不冲突的。

        在特定的环境中， 表锁可能性能良好。 例如， READ LOCAL表锁支持某种类型的并发写操作。另外， 写锁比读锁有更高的优先级， 即使有毒操作用户已经排在队列中， 一个被申请的写锁仍可以排队在锁队列的前列(写锁被安置在读锁之前， 而读锁不能排在写锁之前)。

        虽然存储引擎管理自己的锁， MySQL本身也能使用各种有效的表锁，以用于各种目的。 例如Mysql服务器可以在语句中， 如ALTER TABLE语句中， 使用表锁， 而不用考虑存储引擎。

        行级锁(Row Locks)
        行级锁可以支持最大的并发处理(同时也带来最大的锁开销)。 众所周知， 行级锁在InnoDB和Falcon存储引擎中已得以实现， 在其他的一些存储引擎也有实现。 行级锁由存储引擎实现， 而不是由MySQL服务器。 服务器完全不了解存储引擎里的锁实现方式。

1.3  事务
     在事务的概念产生之前的很长一段时间内， 人们都无法利用到数据库的更多先进特征。 事务是一组原子性的SQL查询语句， 也可以被看作一个工作单元。 如果数据库引擎能够成功的对数据库应用所有的查询语句，他就会执行所有的查询， 但是， 如果任何一条查询语句因为奔溃或者其他原因而无法执行， 那么所有的语句都不会执行。 也就是说， 事务内的语句要么全部执行， 要么一句也不执行。

     除非系统通过ACID测试， 否则空谈事务概念是不够的。 ACID代表了原子性(Atomicity)、 一致性(Consistency)、 隔离性(Isolation)和持久性(Durability). 这些概念与事务的处理标准密切关联， 一个有效的事务处理系统必须满足相关标准。 
     原子性(Atomicity) : 
        一个事务必须被视为一个单独的内部"不可分"的工作单元， 以确保整个事务要么全部执行， 要么全部回滚。 当一个事务具有原子性能， 该事务绝对不会被部分执行， 要么完全执行， 要么根本不执行。
    一致性(Consitency):
        数据库总是从一种一致性状态转换到另一种一致性状态。
    隔离性(Isolation):
        某个事物的结果只有在完成之后才对其他事务可见。 
    持久性(Durability):
        一旦一个事务提交， 事务所做的数据改变将是永久的。 这意味着数据改变已被记录， 即使系统奔溃， 数据也不会因此丢失。 持久性是个有点模糊的概念， 因为实际上持久性也分很多级别。有些持久性策略提供一种强壮的安全保证，另一些则未必。另外也没有什么东西是100%永远持久的。

    ACID 事务确保了银行不会丢你的钱， 而这种特性在应用逻辑设计中是很难实现的， 舌诊不可能实现。 一个ACID兼容的数据库服务器， 要为事务处理做大量的复杂工作， 确保ACID特性的实现， 而这也许是用户未能察觉的。

    正像锁粒度的增加会导致锁开销的增长一样， 这种事务处理中的额外安全措施， 也导致数据库服务器要完成更多额外工作。通常，一个支持ACID特性的数据， 相对于不支持这种特性的数据库，需要更强的CPU处理能力， 更大的内存和更多的磁盘空间。

    正如本章不断重复的， 这正是选用MySQL存储引擎架构的有利之处。用户可以根据应用是否需要事务处理， 选择相应的存储引擎。 如果对于某些类型的数据查询， 用户不需要整整的事务处理，它可以选择一个非事务处理型的存储引擎来实现查询， 以获得更高的处理性能。 用户也可以使用LOCK TABLES语句， 为应用提供某种级别的数据保护， 而这些选择完全由用户自主决定。

1.3.1   隔离性
        隔离的问题比想象的要复杂。 SQL标准定义了4类隔离级别， 包括一些具体规则， 用来限定事务内外的哪些改变是可见的， 哪些是不可见的。 低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

        下面简单介绍四种隔离级:
        READ UNCOMMITTED (读取未提交内容)
        在READ UNCOMMITTED隔离级， 所有事务都可以"看到"未提交事务的执行结果。 在这种级别上， 可能会产生很多问题，除非用户真的知道自己在做什么， 并有很好的理由选择这样做。 本隔离级很少用于实际应用， 因为他的性能也不比其他级别好多少， 而别的级别还有其他更多的优点。 读取未提交数据，也称之为"脏读"(Dirty Read).

        READ COMMITTED(读取提交内容)
        大多数数据库系统的默认隔离级别是READ COMMITTED(但这不是MySQL默认的!)。它满足了隔离的早前简单定义: 一个事务在开始时， 只看见已经提交事务所做的改变， 一个事务从开始到提交前，所做的任何数据改变都是不可见的， 除非已经提交。 这种隔离级别也支持所谓的"不可重复读"(Nonrepeatable Read)。这意味着用户运行同一语句两次， 看到的结果是不同的。

        REPEATABLE READ(可重读)
        REPEATABLE READ隔离级解决了READ UNCOMMITTED隔离级导致的问题。 它确保同一事务的多个实例在并发读取数据时，会"看到同样的"数据行。 不过理论上，这回导致另一个棘手问题:幻读(Phantom Read).简单来说， 幻读指当用户读取某一范围的数据行时， 另一个事务有在该范围内插入了新行， 当用户在读取该范围的数据行时， 会发现有新的"幻影(Phantom)"行。InnoDB和Falcon存储引擎都遵循这种设置， 可参考后面第6章， 了解如何改变这种设置。 其他一些存储引擎也以此为默认设置， 不过具体设置还要看相关引擎的具体规定。

        SERIALIZABLE(可串行化)
        SERIALIZABLE是最高级别的隔离级别， 它通过强制事务的顺序，是指不可能相互冲突， 从而解决幻读的问题。 简言之，SERIALIZABLE是在每个度的数据行上加锁。 在这个级别， 可能导致大量的超时现象和竞争现象。

        ANSI SQL隔离级
        隔离级             脏读         不可重复读可能性           幻读可能性      加锁读
        READ UNCOMMITTED   是           是                         是              否
        READ COMMITTED     否           是                         是              否
        REPEATABLE READ    否           否                         是              否
        SERIALIZABLE       否           否                         否              是

        总结:
        脏读(dirty read) : 未提交的数据也能读取到， 这就是脏数据。 允许脏读， 将影响数据的完整性，另外外键约束也遭到破坏， 而且会忽略唯一性约束。
        
        不可重复读(unrepeatable read) : 这意味着， 如果在T1时间读取某一行， 在T2时间又去读取这一行，可是这一行内容可能已经更改或者已经不存在。 

        幻读(Phantom Read) : 这说明， 如果你在T1时间执行一个查询， 而在T2时间在执行这个查询， 此时可能有其他程序向这个范围插入了新的行， 这会影响你的结果。 与不可重复读的区别是:在幻读中，已经读取的数据不会改变， 只是与以前相比， 会有更多的数据满足你的查询条件。
        更新丢失(Lost Update): 当两个或多个事务选择同一行， 然后基于最初选定的值更新该行时， 由于每个事务都不知道其他事务的存在， 就会发生丢失更新问题--最后更新覆盖了由其他事务所做的更新。

1.3.2   死锁
        死锁是指两个或者多个事务在统一资源上湖乡占用， 并请求加锁时， 而导致的恶性循环现象。 当多个事务以不同顺序视图加锁统一资源时， 就会产生死锁。 任何时间，多个事务同时加锁一个资源， 一定产生死锁。 
        Transaction #1
        START TRANSACTION;
        UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 and date = '2002-05-01';
        UPDATE StockPrice SET close = 19.80 WHERE stock_id = 3 and date = '2002-05-02';
        COMMIT;

        Transaction #2
        START TRANSACTION;
        UPDATE StockPrice SET high = 20.12 WHERE stock_id = 3 and date = '2002-05-02';
        UPDATE StockPrice SET high = 47.20 WHERE stock_id = 4 and date = '2002-05-01';
        COMMIT;

        这两个事务都执行了第一行的更新， 都试图去锁定第二个行， 结果是发现这第二个行已经被其他事务锁定，所以等待对方结束， 就陷入无限等待中， 除非有外部因素介入， 才能解除死锁。

        为了解决这种问题， 数据库系统实现了各种思索检测和思索超时机制。 对于更复杂的系统， 例如InnoDB存储引擎， 可以预知循环相关性， 并立刻返回错误。 这种解决方式实际很有效， 否则思索将导致很慢的查询。 其他的解决方式， 是让查询达到一个锁等待超时时间， 然后再放弃争用， 但这种方法不够好。目前InnoDB处理思索的方法是，回滚拥有最少排他行级锁的事务(一种对最易回滚事务的大致估算)。

        锁现象和锁顺序是因存储引擎而异的， 某些存储引擎可能会因为使用某种顺序的语句导致死锁， 其他的却不会， 思索现象具有双重性:有些是因为真实数据的冲突产生的， 无法避免， 有些则是因为存储引擎的工作方式导致的。

        如果不以部分或全部的方式回滚某个事务， 思索将无法解除。 在事务性的系统中，这是个无法更改的事实。 用户在设计应用时， 就应考虑这种问题的处理。 许多应用在事务开始时， 可以做简单的判定， 决定重做事务。

1.3.3   事务日志
        事务日志可使事务处理过程更加高效。 和每次数据以改变就更新磁盘中表数据的方式不同， 存储引擎可以先更新数据在内存中的拷贝。 这非常快。 然后， 存储引擎将数据改变记录写入事务日志， 它位于磁盘上， 因此具有持久性。 这相对比较快，因为追加日志事件导致的写操作， 只涉及了磁盘很小区域上的顺序I/O(Sequential I/O), 而替代了写磁盘中表所需要的大量随机I/O(Random I/O). 最后， 相关进程会在某个时间把表数据更新到磁盘上。 因此， 大多存储引擎都选用了这种技术， 也是通常所说的预写式日志(Write-Ahead Logging)，利用两次磁盘写入操作把数据改变写入磁盘。

        如果数据更新已写入事务日志， 却还未写入磁盘的表中， 而发生系统奔溃， 存储引擎将会在重启后恢复相关数据改变。 具体的恢复方式因存储引擎而异。

1.3.4   MySQL中的事务
        MySQL AB提供了三个事务型存储引擎: InnoDB, NDB Cluster和Falcon. 还有几个第三方引擎也支持事务处理；目前最知名的第三方事务性引擎是solidDB和PBXT.

        AUTOCOMMIT(自动提交)
        MySQL默认操作模式是AUTOCOMMIT模式。 这意味着除非显示地开始一个事务，否则它将把每个查询视为一个单独事务自动执行。 在当前连接中， 可以通过变量设置， 启用(Enable)和禁用(Disable) AUTOCOMMIT模式:
        SHOW VARIABLES LIKE 'AUTOCOMMIT'; //查看变量AUTOCOMMIT的值

        SET AUTOCOMMIT = 1;               //设置自动提交功能开启

        SET TRANSACTION ISOLATION LEVEL   //设置隔离级， 新的隔离级将在下一个事务开始后生效。
        也可以在配置文件中，为整个服务器设置隔离级；或者使用下列命令， 只为当前会话设置隔离级。
        mysql > SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
        MySQL可以识别所有的4个ANSI标准隔离级， InnoDB引擎也支持所有的隔离级。 其他的存储引擎对隔离级的支持， 则因不同隔离级别而异。

        在事务中混合使用存储引擎
        MySQL没有在服务器层管理事务，而是由下一层的存储引擎实现事务的处理。 这意味着， 在单一事务中， 混合使用不同存储引擎并不可靠。 MySQL AB正打算为服务器增加一个高层次的食物管理服务， 使用户可以安全地在事务中混合和匹配事务性表。 现在还不是时候， 所以要小心一些。

        在一个事务中， 如果混合使用事务性表和非事务性表(如InnoDB和MyISAM)，例如事务处理一切顺利，那么结果也会正常。 但是，如果事务须回滚， 那么在非事务性表上做的修改将无法取消。 浙江导致数据库处于数据不一致的状态， 在这种状况下， 很难对数据进行回复， 并且事务会变得悬而未决。 这正好说明了为每个表选择正确的存储引擎多么重要。

        如果在一个非事务性表上进行事务性操作， MySQL通常不会给出警告或报错信息。 有时回滚事务会产生一个警告信息"Some nontransactional changed tables couldn't be rolled back", 但在大多数情况下， 操作一个非事务性表不会得到任何提示。

        隐式和显式锁定
        InnoDB使用二相锁定协议(Two-Phase Locking Protocol).一个事务在执行过程中的任何时候， 都可以获得锁， 但只有在执行COMMIT或ROLLBACK语句后，才可以释放这些锁。 前文描述的锁定机制是隐式锁定。 InnoDB会根据用户的隔离级别，自动处理锁定。

        不过，InnoDB也支持显示锁定， 例如一下语句(不代表全部):
        SELECT ... LOCK IN SHARE MODE
        SELECT .. FOR UPDATE

        MYSQL也支持LOCK TABLES和UNLOCK TABLES命令， 这些命令由MySQL服务器实现， 而不是由存储引擎。
        这些命令各有其用途， 不能完全取代事务的作用。 如果需要事务性处理， 应该选择使用事务性引擎。

1.4 多版本并发控制
    大多数MySQL的事务性存储引擎， 例如InnoDB，Falcon和PBXT，不是简单地使用行加锁的机制，而是选用一种叫做多版本并发控制(MVCC)的技术和行加锁机制。MVCC(Multiversion Concurrency Control)不是MySQL独有的技术，Oracle、PostgreSQL以及其他一些数据库系统也使用同样的技术。

    可以将MVCC设想成一种行级加锁的变形， 它避免了很多情况下的加锁操作， 大大降低了系统开销。 依赖于具体技术实现， 它可以在读取期间锁定需要的记录的同时， 还允许非锁定读取。

    MVCC是通过及时保存在某些时刻的数据快照而得以实现的。 这意味着同一事务的多个实例， 在同时运行时， 无论每个实例运行多久， 他们看到的数据视图是一致的；而同一时间，对于同一张表， 不同事务看到的数据却是不同的！如果用户之前对此没有概念， 这可能让人有点迷惑， 但随着熟悉程度的加深， 这个概念也很容易理解。

    每个存储引擎实现MVCC的方式是不同的。 例如乐观并发控制(Optimistic Concurrency Control)、悲观并发控制(Pessimistic Concurrency Control). 下面通过描述InnoDB简化版的行为方式，距离说明MVCC的工作原理。

    InnoDB通过为每个数据行增加两个隐含的方式来实现MVCC。 这两个隐含值记录了行的创建时间，以及它的过期时间(或者叫删除时间)。 每一次， 开始一个新事物的时候， 版本好都会自动递增。 每个事务都会保存它在开始时的"当前系统版本"的记录， 而每个查询都会根据事务的版本号， 检查每行数据的版本好。 下面看一下， 当事务隔离级设置为REPEATABLE READ时， MVCC在实际操作中的应用方式:
    SELECT 
        InnoDB检查每行数据， 确保它们符合两个标准:
        1) InnoDB只查找版本早于当前事务版本的数据行(也就是数据行的版本必须小于等于事务的版本)， 这确保了当前事务读取的行都是在事务开始前已经存在的， 或者是由当前事务创建或修改的行。
        2)数据行的删除版本必须是未定义的， 或者大于事务版本的， 这保证了事务读取的行， 在事务开始是未被删除的。
        只有通过上述两项测试的数据行， 才会被当作查询结果返回。
    INSERT
        InnoDB为每个新增行记录当前系统版本号。
    DELETE
        InnoDB为这个删除行记录当前系统版本号， 作为行删除标识。
    UPDATE
        InnoDB会为每个需要更新的行， 建立一个新的行拷贝， 并且为新的行拷贝记录当前的系统版本号。 同时，也为更新前的旧行，记录系统的版本号作为旧行的删除版本标识。
    保存这些额外记录的好处是使大多数数据操作都不必申请加锁， 这使数据操作变得尽可能的快， 因为读操作只需要选取符合标准的行数据即可。 这种方式的确定是， 存储引擎必须为每行数据， 存储更多的额外数据，做到更多的行检查工作， 以及处理一些额外的整理操作(Housekeeping Operations).

1.5 MySQL的存储引擎
    mysql> show table status like 'help_category' \G
    *************************** 1. row ***************************
               Name: help_category           //表名
             Engine: MyISAM                  //表的存储引擎
            Version: 10                      //
         Row_format: Fixed                   //行格式。对于MyISAM可能是Dynamic、Fixed或Compressed。动态行的行长度可变，因为它们可能包含有可变长的字段，例如VARCHAR或BLOB类型字段。固定行，是指行长度相同，由不可变长的字段组成，例如CHAR和INTEGER字段。 压缩行只存在于压缩表中.
               Rows: 40                      //表中行数。对于非事务性表，这个值是精确的。 对于事务性表，这个值通常是个估算值。
     Avg_row_length: 581                     //平均每行包含的字节数。
        Data_length: 23240                   //整个表的数据量(以字节计算)
    Max_data_length: 163536961468891135      //表可以容纳的最大数据量。
       Index_length: 3072                    //索引占用磁盘空间的大小
          Data_free: 0                       //对于MyISAM表，表示已分配，但现在未被使用的空间。这部分空间包含了以前被删除的行，这些空间可以用于以后的INSERT语句。
     Auto_increment: NULL                    //下一个AUTO_INCREMENT值
        Create_time: 2013-04-27 18:21:40     //表最初创建时的时间
        Update_time: 2013-04-27 18:21:45     //表数据最近被更新的时间
         Check_time: NULL                    //使用CHECK TABLE命令或myisamchk工具检查表时的最近检查时间
          Collation: utf8_general_ci         //指表中的默认字符集和字符列排序规则Collation.
           Checksum: NULL                    //如果启用，则对整个表的内容计算实时的校验和(Checksum).
     Create_options:                         //指表创建时的其他所有选项
            Comment: help categories         //本字段包含了其他额外信息。对于MyISAM表，还包含了注释，如果有注释，将是在表创建时设定的。如果表使用InnoDB存储引擎，将显示InnoDB表空间的剩余空间。如果表是个视图，注释里将包含VIEW的文本字样。

    MyISAM引擎
    在性能和可用特征之间， MyISAM提供一种良好的平衡， 这些特征包括全文检索、压缩、空间函数(GIS)。它不支持事务和行锁。

    存储
    一般来说，MyISAM将每个表存储成两个文件:数据文件和索引文件。两个文件的扩展名分别为.myd和.myi。
    MyISAM的格式平台通用的，这意味着用户可以在不同架构的服务器上毫无问题的相互拷贝数据文件和索引文件。 例如可以从Intel架构的服务器上复制文件到PowerPC或Sun SPARC架构的服务器。
    MyISAM还可以包含动态行(Dynamic Row)和静态行(Static Row，即固定长度行)。 MySQL会根据表定义决定选用何种行格式。 MyISAM表的可容纳的行总数，一般只受限于数据库服务器的可用磁盘空间的大小，以及操作系统允许创建的最大文件的大小。

    在MySQL 5.0中，默认配置的含有可变长行定义的MyISAM表可支持256TB的数据处理，并使用6字节的指针记录数据。 更早的MySQL版本默认使用4字节指针，最大可处理4GB的数据。 所有的MySQL版本都支持最大8字节的指针。 如果想改变MyISAM表上的指针大小(调大或调低)，必须在表创建选项MAX_ROWS和AVG_ROW_LENGTH中指定相关的值， 这些选项代表了用户预计使用的表大小。
    CREATE TABLE mytable (
        a INTEGER NOT NULL PRIMARY KEY,
        b CHAR(18) NOT NULL
    ) MAX_ROWS = 1000000000 AVG_ROW_LENGTH = 32;
    在这个例子中，要求MySQL为表数据至少准备32GB的数据存储容量。 可以简单的查询下表的状态，获得MySQL的实际操作结果。
    
mysql> show table status like 'hwtrip_administrators' \G
*************************** 1. row ***************************
           Name: hwtrip_administrators
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 82
 Avg_row_length: 599
    Data_length: 49152
Max_data_length: 0
   Index_length: 0
      Data_free: 0
 Auto_increment: 105
    Create_time: 2013-05-08 18:44:38
    Update_time: NULL
     Check_time: NULL
      Collation: utf8_general_ci
       Checksum: NULL
 Create_options: 
        Comment: 

第三章 架构优化和索引

优化设计不良或索引不佳的架构(Schema)能把性能提高几个数量级。 如果需要提高性能，就必须为运行的特定查询设计架构和索引， 还要评估不同类型查询的性能需求， 因为更改某个查询或架构的一部分会对其他部分中造成影响。优化通常需要权衡取舍， 例如， 为了加快数据读取而添加的索引会减慢更新的速度，同样， 非规范化架构能加快某些类型的查询， 但却会让其他类型的查询变慢。 添加计数器和汇总表是优化查询的好方法，但它们的维护代价很高。

有时必须超越开发人员的身份， 质疑手头的商业需求。 通常撰写商业需求的人都不是数据库系统的专家， 他们不会理解这些需求对性能的影响。 如果告诉他们一个小小的特性会使硬件需求翻倍， 他们也能理解并不是非得要这个特性。

架构优化和索引既需要大局观， 又需要专注于细节。 你要了解整个系统， 以弄清楚个部分如何相互影响。 本章首先讨论数据类型， 然后讨论覆盖索引策略和规范化。 最后则对存储引擎做一些说明。

3.1 选择优化的数据类型
    MySQL支持很多种不同的数据类型， 并且选择正确的数据类型对于获得高性能至关重要。不管选择何种类型， 下面的简单原则都会有助于作出更好的选择:
    最小通常最好
        一般来说， 要是这使用能正确地存储和表示数据的最小类型。 更小的数据类型通常更快， 因为他们使用更少的磁盘空间、内存和CPU缓存，而且需要的CPU周期也更少。

        但是要确保不会低估需要保存的值， 在架构中的多个地方增加数据类型的范围是一件极其费时费力的工作。 如果不确定需要什么数据类型， 就选择你认为不会超出范围的最小类型。(如果系统不是非常繁忙或不会保存太多的数据，再或者还处于设计的早期， 就可以在以后轻易的更改它。)

    简单就好
        越简单的数据类型，需要的CPU周期就越少。 例如，比较整数的代价小于比较字符， 因为字符集和排序规则使字符比较更复杂。 这里有两个例子: 一是应该使用MySQL内建类型来保存日期和时间，而不是使用字符串；而是应该使用整数来保存IP地址。
    尽量避免NULL
        要尽可能的把字段定义为NOT NULL。 即使应用程序无须保存NULL, 也有许多表包含了空列， 这仅仅是因为它为默认选项。 除非真的要保存NULL，否则就把列定义为NOT NULL。
        MySQL难以优化引用了可空列的查询， 它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间， 还需要在MySQL内部进行特殊处理。 当可空列被索引的时候，每条记录都需要一个额外的字节， 还能导致MyISAM中固定大小的索引变成可变大小的索引。
        即使要在表中存储"NULL"的字段， 还是有可能不使用NULL的。 考虑使用0、特殊值或空字符串来代替它。
        把NULL列改为NOT NULL带来的性能提升很小， 所以除非确定它引入了问题， 否则就不要把它当成优先的优化措施。 然后， 如果计划对列进行索引， 就要尽量避免把它设置为NULL.
    
    决定特定列的数据类型的第一步就是大致决定数据的类型:数据、字符串、时间等。 这通常很直观， 但是我们也会说道一些不那么直观的特殊情况。

    第二步是确定特定的类型。 许多MySQL数据类型能够保存同类的数据，但是存储的范围、精度或物理空间(磁盘上或内存中)却不相同。 一些数据类型还有特殊的行为或属性。

    例如，DATETIME和TIMESTAMP能保存同样类型的数据: 日期和时间，精度为秒。 然而，TIMESTAMP使用的空间只有DATETIME的一般， 还能保存时区， 拥有特殊的自动更新能力。 零一方面，它允许的范围要小得多， 并且在某些时候， 它的特殊功能会成为障碍。

    这里我们讨论了基本的数据类型。 MySQL为了保持兼容性， 支持很多别名，比如INTEGER, BOOL, NUMMERIC。它们都只是别名， 它们会让人迷惑，但却不会影响性能。

3.1.1 整数
    数字有两种类型: 整型(whole number)和实数(real number)。 如果存储整数， 就可以使用这几种整数类型: TINYINT, SMALLINT, MEMDIUMINT, INT, BIGINT, 它们分别需要8、16、24、32、64位存储空间。 它们的范围为-2^(n-1) ~ 2^(n-1) -1， 这里的n是所需存储空间的位数。

    整数类型有可选用的UNSIGNED属性， 它表示不允许复数， 并大致把正上限提高了一倍。 例如，TINYINT UNSIGNED的范围为0-255， 而非-127~128

    有符号和无符号类型占用的存储空间是一样的，性能也一样。 因此可以根据实际情况采用合适的类型。

    你的选择将会决定MySQL把数据保存在内存中还是磁盘上。 然而，整数运算通常使用64位的BIGINT整数， 即使是32位架构也如此。(一些聚合函数是例外， 他们使用DECIMAL或DOUBLE进行计算)

    MySQL还可以对整数类型定义宽度， 比如INT(11)。 这对于大多数应用程序都是没有意义的: 它不会限制值的范围，只规定了MySQL的交互工具(例如命令行客户端)用来显示字符的个数。对于存储和计算， INT(1)和INT(20)是一样的。

    提示: Falcon存储引擎和MySQL AB提供的其他存储引擎内部存储整数的机制是不同的。用户不能控制存储数据的实际大小。 第三方存储引擎， 例如Brighthouse， 也有自己的存储格式和压缩方案。

3.1.2 实数
    实数有分数部分。 然而，它们并不仅仅是分数。 可以使用DECIMAL保存比BIGINT还大的整数。 MySQL同时支持精确与非精确类型。
    FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。 如果想知道浮点运算到底如何进行， 则要研究平台浮点数的具体实现。

    DECIMAL类型用于保存精确的小数。 在MySQL5.0及以上版本， DECIMAL类型支持精确的数学运算。 MySQL4.1和早期版本对DECIMAL值执行浮点运算， 它会因为丢失精度而导致奇怪的结果。 在这些MySQL版本中，DECIMAL仅仅是"存储类型"。

    在MySQL5.0及以上版本中，服务器自身进行了DECIMAL运算， 因为CPU并不支持对它进行直接计算。 浮点运算会快一点， 因为计算直接在CPU上进行。

3.1.3 字符串类型
    MySQL支持很多种字符串类型， 它们之间有很多不同。 这些数据类型在MySQL4.1和5.0中有很大的变化， 这使得它更加复杂。 从MySQL4.1起， 每个字符串列都有自己的字符集和排序规则。 这会极大的影响性能。

    VARCHAR和CHAR类型
    两种主要的字符串类型是VARCHAR和CHAR。 不幸的是， 很难确切地解释这两种类型是怎样被保存到磁盘或内存中的， 因为具体实现依赖于存储引擎。下面的情况假设使用的是InnoDB和/或MyISAM。 如果不是， 请参考所使用的存储引擎的文档。

    先看看VARCHAR和CHAR是如何被保存到磁盘上的。 要知道存储引擎可能会使用不同的方式把CHAR和VARCHAR类型保存到内存中，并且服务器从存储引擎取回这些值的时候还可能会把它转换为其他存储格式。 下面是两种类型的比较:
    VARCHAR
        VARCHAR保存了可变长度的字符串， 是使用得最多的字符串类型。 它能比固定长度类型占用更少的存储空间， 因为它只占用了自己需要的空间。(也就是说较短的值占用的空间就较少)。 例外情况是使用ROW_FORMAT=FIXED创建的MyISAM表， 它为每行使用固定长度的空间，可能会造成浪费。

        VARCHAR使用额外的1到2字节来存储值的长度。 如果列的最大长度小于或等于255，则使用1字节， 否则就使用2字节。假设使用latin1字符集， VARCHAR(10)将会占用11字节的存储空间。VARCHAR(1000)则会占用1002字节， 因为需要2个字节来保存长度信息。

        VARCHAR能节约空间，所以对性能有帮助。 然而由于行的长度是可变的，它们在更新的时候可能会发生变化，这会引起额外的工作。 如果行的长度增加并不在适合于原始的位置时， 具体的行为则会和存储引擎相关。 例如MyISAM会把行拆开，InnoDB则可能进行分页。 另外的存储引擎还可能不会在合适的位置更新数据。

        当最大长度大于平均长度，并且很少发生更新的时候， 通常适合使用VARCHAR。这时候碎片就不会成为问题。 还有当你使用复杂的字符集， 比如UTF-8时， 它的每个字符都可能会占用不同的存储空间。

        在5.0及以上版本，无论是保存还是取值，MySQL都会保留字符串末尾的空格。 但是在4.1及之前的版本，这些空格会被去掉。

    CHAR
        CHAR是固定长度的。 MySQL总是为特定数量字符分配足够的空间。 当保存CHAR值的时候，MySQL会去掉任何默认的空格。进行比较的时候，空格会被填充到字符串末尾。

        CHAR在存储很短的字符串或长度近似相同的字符串的时候很有用。例如，CHAR适合用存储用户密码的MD5哈希值，它的长度总是一样的。对于经常改变的值, CHAR也好于VARCHAR， 因为固定长度的行不易产生碎片。 对于很短的列，CHAR效率也高于VARCHAR。 CHAR(1)字符串对于单字节字符集智慧占用一个字节，但是VARCHAR(1)则会占用两个字节， 因为有1个字节用来存储长度信息。

    数据如何保存取决于存储引擎，并非所有的存储引擎都会按照相同的方式来处理定长和可变长度的字符串。Memory存储引擎使用了固定长度的行， 因此当它面对可变长度字段的时候就会分配可能的最大空间。 而Falcon引擎即使是对固定长度的CHAR字段， 也会使用长度可变的列。 但是，填充和截取空格的行为在各个存储引擎之间都是一样的， 因为这是MySQL服务器自身的行为。

    CHAR和VARCHAR的兄弟类型是BINARY和VARBINARY，它们用于保存二进制字符串。 二进制字符串和传统的字符串很相似， 但是它们保存的是字节，而不是字符。 填充也有所不同: MySQL使用\0填充BINARY值，而不是空格，并且不会在获取数据的时候把填充的值截掉。

    它们在需要存储二进制数据并且想让MySQL按照字节进行比较的时候是有用的。 字节比较的优势并不仅仅体现在大小写敏感上。MySQL按字节的数值进行比较，比按字符比较简单的多，效率也更高。

    慷慨是不明智的
    使用VARCHAR(5)和VARCHAR(200)保存'hello'占用的空间都是一样的，那么使用较短的列有任何优势吗?
    其实有巨大的优势。 较大的列会使用更多的内存， 因为MySQL通常会分配固定大小的内存块来保存值。这对排序或使用基于内存的临时表尤其不好。 同样事情也会发生在使用文件排序或者磁盘的临时表的时候。
    最好的策略就是只分配真正需要的空间。

    BLOB和TEXT类型
    BLOB和TEXT分别以二进制和字符形式保存大量数据。
    事实上，它们各自有自己的数据类型家族:字符类型有TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT和LONGTEXT，二进制类型有TINYBLOB, SMALLBLOB, MEDIUMBLOB, LONGBLOB.
    BLOB等同于SMALLBLOB, TEXT等同于SMALLTEXT。

    和其他类型不同，MySQL把BLOB和TEXT当成有实体的对象来处理。 存储引擎通常会特别地保存它们。 InnoDB在它们较大的时候会使用单独的"外部"存储区域来进行保存。 每个值在行里边都需要1到4个字节，并且还需要足够的外部存储空间爱你来保存实际的值。

    BLOB和TEXT唯一的区别就是BLOB保存的是二进制数据，没有字符集和排序规则， 但是TEXT保存字符串，有字符集和排序规则。

    MySQL对BLOB和TEXT列的排序方式和其他类型不同: 它不会按照字符串的完整长度进行排序，而只是按照max_sort_length规定的前若干个字节进行排序。 如果只按照开始的几个字符排序， 就可以减少max_sort_length的值或使用ORDER BY SUBSTRING(column, length).

    MySQL不能索引这些数据类型的完整长度，也不能为排序使用索引。

    如何避免磁盘上的临时表
    由于Memory存储引擎不支持BLOB和TEXT类型，使用了BLOB和TEXT列并且需要隐式临时表的查询将不得不使用磁盘上的MyISAM临时表， 即使只有几列也会这样。 这会导致严重的性能开销。 即使把MySQL配置为使用RAM磁盘上的临时表， 也需要很多昂贵的操作系统调用。(Maria存储引擎会把所有的东西都缓存到内存中，有助于减轻这个问题。)

    最好的办法是尽可能的避免使用BLOB和TEXT类型。 如果不能避免，就可以使用ORDER BY SUBSTRING(column, length)把这些值转换为字符串， 让它们使用内存中的临时表。 要保证使用的子字符串足够短， 不要让临时表变得过大， 以致超过max_heap_size或tmp_table_size的大小， 否则MySQL会把表转换为磁盘上的MyISAM表。

    如果在解释器(EXPLAIN)中的Extra列显示"Using Temporary"， 这就说明使用了隐式临时表。

    使用ENUM代替字符串类型
    有时可以使用ENUM列来代替传统的字符串类型。 ENUM列可以存储65535个不同的字符串。 MySQL以非常紧凑的方式保存了它们， 根据列表中的数量，MySQL会把它们压缩到1到2个字节中。 MySQL在内部把每个值都保存为整数， 以表示值在列表中的位置，并且还保留了一份"Lookup table"来表示整数和字符串在表的.frm文件中的映射关系。
