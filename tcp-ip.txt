IP头数据结构
           |  5~15 |  即最少32字节，最多60字节
     0                   1                   2                   3  
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   --+--
   |Version|  IHL  |Type of Service|          Total Length         |     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |
   |         Identification        |Flags|      Fragment Offset    |     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    (最少)
   |  Time to Live |    Protocol   |         Header Checksum       |    32 字节
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |
   |                    Destination Address                        |     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   --+--
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    数据结构如下:
    struct iphdr
    {
    #if __BYTE_ORDER == __LITTLE_ENDIAN            // 小端地址
        unsigned int ihl:4;                        // 网络头长度(IHL internet header length)  4位, 5~15长度
        unsigned int version:4;                    // 版本号 4位
    #elif __BYTE_ORDER == __BIG_ENDIAN             // 大端地址
        unsigned int version:4;
        unsigned int ihl:4;                        // IP首部长度最长为60字节，即15*32(bit)/8(bit) = 60字节，最少32字节
    #else
    # error "Please fix <bits/endian.h>"
    #endif
        u_int8_t tos;          // 服务类型(TOS) type of service 8位
        u_int16_t tot_len;     // IP数据报的总长度 16位，因此可以表示0~65535字节，即最长65535字节，即64KB，总长度也是IP首部中必要的字段。数据长度=总长度-报头长度
        u_int16_t id;          // 标识符，长度为16位
        u_int16_t frag_off;    // 控制标志flags(3bit)和段偏移(13位)
        u_int8_t ttl;          // 生存周期(TTL time to live) 8bit, 用于指定数据报允许保留在网络上的时间。
        u_int8_t protocol;     // 协议 8bit, 用于指定数据报数据区中携带的消息是由哪种高级协议建立的。ICMP为1,TCP为6，UDP为17。 协议号分配RFC790.
        u_int16_t check;       // 报头校验和16比特，仅用于IP报头校验和。
        u_int32_t saddr;       // 源IP地址
        u_int32_t daddr;       // 目的IP地址
        /*The options start here. */  // 选项，填充字段用于确保将选项字段填充为最少32个比特位，以保证IP报头以32位结束。
    };

    1) Version: 4 bits
        表明互联网头的格式.
    2) IHL: 4 bits
        互联网头长度(Internet Header Length)，单位是32位字，从而指向数据的开始。 注意合法的头最小长度为5. 即不带有选项和填充部分。只包含前面的5个32位。
    3) Type of Service: 8 bits
        服务类型提供了想要的服务质量的抽象参数标识。 这些参数用于在通过特定网络传输数据报时候，辅助选择真正的服务参数。几个网络提供服务优先级，也就是将高优先级访问处理的比其他访问优先处理。(一般在高负载的情况下通过只接受高于特定优先级的访问。)主要的选择是在低延迟，高可靠性和高吞吐量三者间进行权衡。
        TOS 8 bits
             0        1        2        3       4        5         6       7
        +--------+--------+--------+--------+--------+--------+--------+--------+
        |        Precedence        |    D   |    T   |    R   |    0   |    0   |
        +--------------------------+--------+--------+--------+--------+--------+
        Bits 0-2:   优先级.
        Bit 3:  延迟级别 0 = 正常延迟, 1 = 低延迟.
        Bit 4:  吞吐量级别 0 = 正常吞吐量, 1 = 高吞吐量.
        Bit 5:  可靠性级别 0 = 正常可靠性, 1 = 高可靠性.
        Bit 6-7:    保留位，待将来使用.
        优先级
        111 -   Network Control
        011 -   Flash
        110 -   Internetwork Control
        010 -   Immediate
        101 -   CRITIC/ECP
        001 -   Priority
        100 -   Flash Override
        000 -   Routine

        使用延迟，吞吐量和可靠性标识可能增加服务成本(在某种意义上说)。在很多网络上这些参数中的一个具有较好的性能，而另外的却有糟糕的性能。除了非常不常见的情况，这三个标识都应该被设置。
        服务类型用于指定通过互联网处理数据报传输。
    4) Total Length: 16 bits
        总长度是数据报的长度， 单位是8位字节， 包括了互联网头和数据。 这个域允许数据报的长度达到65,535个8字节。 这样唱的数据报对于大多数的主机和网络都是不实际的。所有的主机必须准备接受高达576字节的数据报(不管是整个到达还是在帧里边)。推荐主机仅在目的主机已经准备好接受更大的数据报的情况下，发送比576字节大的数据报。
        数字576被选择来允许被传输的加上必要的头信息的合理尺寸数据块。
        例如， 这个尺寸允许数据块是512字节加上64头字节来匹配一个数据报。 最大的互联网头是60字节， 一般的互联网头是20字节， 允许利润率更高层次的协议头。

    5) Identification: 16 bits
        由发送方赋予的一个标识符值，帮助组装一个数据报片段。

    6) Flags: 3 bits
        各种的控制标志
        Bit 0:  保留，必须为0
        Bit 1:  (DF) 0 = May Fragment, 1 = Don't Fragment.
        Bit 2:  (MF) 0 = Last Fragment, 1 = More Fragments.

TCP header
        0                   1                   2                   3   
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Source Port          |       Destination Port        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                        Sequence Number                        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                    Acknowledgment Number                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Data |           |U|A|P|R|S|F|                               |
       | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
       |       |           |G|K|H|T|N|N|                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           Checksum            |         Urgent Pointer        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                    Options                    |    Padding    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                             data                              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        struct tcphdr
          {
            u_int16_t source;           // 源端口号 16位
            u_int16_t dest;             // 目的端口号 16位
            u_int32_t seq;              // 序列号
            u_int32_t ack_seq;          // 确认号
            u_int16_t doff:4;           // 数据偏移，头部长度
            u_int16_t res1:4;           // 保留位
            u_int16_t res2:2;           // 保留位
            u_int16_t urg:1;            // 紧急指针（urgent pointer）有效
            u_int16_t ack:1;            // 确认序号有效
            u_int16_t psh:1;            // 接收方应该尽快将这个报文段交给应用层
            u_int16_t rst:1;            // 重建连接
            u_int16_t syn:1;            // 发起一个连接
            u_int16_t fin:1;            // 释放一个连接
            u_int16_t window;           // 窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数
            u_int16_t check;            // TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。
            u_int16_t urg_ptr;          // 紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。
        };

    TCP(Transmission Control Protocol)　传输控制协议
    TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:
    位码即tcp标志位,有6种标示:SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)
    Sequence number(顺序号码) Acknowledge number(确认号码)
    第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；
    第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包
    第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。
    完成三次握手，主机A与主机B开始传送数据。


    三次握手 请求->应答->再次确认
    1) 客户端向服务器发送SYN=1, 并随即产生一个序列X=1223234324, 一起发送给服务器， 那么服务器接收到SYN=1就知道客户端要求建立连接。
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Source Port          |       Destination Port        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |            Sequence Number X=1223234324                       |         <----------Seq X-------------
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                    Acknowledgment Number                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Data |           |U|A|P|R|S|F|                               |
       | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
       |       |           |G|K|H|T|N|N|                               |
       |       |           | | | | |1| |                               |         <----------SYN=1-------------
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           Checksum            |         Urgent Pointer        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                    Options                    |    Padding    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                             data                              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    2) 服务器接受到SYN和Seq后， 需要确认联机信息， 于是向客户端发送ACK=1, 并随即产生一个Seq Y=89234234234, ACK Seq=X+1, SYN=1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Source Port          |       Destination Port        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |            Sequence Number Y=89234234234                      |         <----------Seq Y-------------
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |       Acknowledgment Number (X+1)1223234325                   |        <-----------ACK Seq = X+1 ----
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Data |           |U|A|P|R|S|F|                               |
       | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
       |       |           |G|K|H|T|N|N|                               |
       |       |           | |1| | |1| |                               |         <----------ACK=1, SYN=1------
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           Checksum            |         Urgent Pointer        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                    Options                    |    Padding    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                             data                              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    3) 客户端端接收到服务器的确认响应后， 检查ACK Seq和ACK是否正确，ACK Seq=X+1, ACK=1, SYN=1, 如果正确，则客户端需要再发起一次确认请求
       ACK Seq = Y+1, 并随即再生成一个序列号Z，一起发送给服务器，这样连接就确立了。
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Source Port          |       Destination Port        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |            Sequence Number Z=90234656234                      |         <----------Seq Y-------------
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |       Acknowledgment Number (Y+1) 89234234235                 |        <-----------ACK Seq = Y+1 ----
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Data |           |U|A|P|R|S|F|                               |
       | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
       |       |           |G|K|H|T|N|N|                               |
       |       |           | |1| | | | |                               |         <----------    ACK=1   ------
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           Checksum            |         Urgent Pointer        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                    Options                    |    Padding    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                        data (X+1)                             |         <----------    X+1  ------
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    SYN攻击
    在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于SYN_RECV状态.
    当收到ACK后，服务器转入ESTABLISHED状态.
    Syn攻击就是攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。
    Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.

    在Linux下可以如下命令检测是否被Syn攻击:
    netstat -n -p TCP | grep SYN_RECV
    一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。
    主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等.但是不能完全防范syn攻击。

    四次握手
    这个是在TCP的连接的拆除时候,需要发送四个包，因此称为四次挥手(four-way handshake)。
    客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。

    +------------+                                                           +------------+
    |   主动方   |                                                           |   被动方   |
    +------------+                                                           +------------+
          |                                                                        |
          |                1.       FIN=1 ACK Seq=Z Seq=X                          |
          | ---------------------------------------------------------------------> |
          |                                                                        |
          |                                                                        |
          |                                                                        |
          |                2.       ACK Seq=X+1 Seq=Z                              |
          | <--------------------------------------------------------------------- |
          |                3.       FIN=1 ACK Seq=X Seq=Y                          |
          | <--------------------------------------------------------------------- |
          |                                                                        |
          |                                                                        |
          |                4.       ACK Seq=Y Seq=X                                |
          | ---------------------------------------------------------------------> |
          |                                                                        |


http://book.51cto.com/art/201210/359900.htm  java程序性能优化
http://foxsp.com/topic/142       PHP程序员瓶颈突破
http://www.agilesharp.com/showtopic-494.aspx 如何找到网站性能瓶颈
http://blog.csdn.net/longeremmy/article/details/8028713 
浏览器加载渲染网页过程解析

    客户端请求一个页面到页面加载完成的全过程:
    1) 客户端浏览器输入请求连接
    2) 浏览器先进性域名解析， 通过本地DNS缓存或者远程DNS解析，将域名对应的IP返回给浏览器
        浏览器缓存DNS查询，过期时间不一。
        不同的浏览器对于DNS查询在不同窗口或者tab之间是否共用缓存结果不一（chrome下刷新被视全新的请求）。
        同一页面共用DNS结果，即请求同页面同源的组件不会进行重复的DNS请求

        结论：一般情况下，每次请求页面或者组件会根据DNS缓存有无和可用与否，进行不定的DNS查询。解析时间与本机缓存或者直接DNS服务器缓存命中与否有关，多在0ms到1000ms之间。
    3) 得到IP后，浏览器就开始发送请求，建立TCP连接，经过三次握手过程后，连接就建立了。
    4) TCP连接建立后， 浏览器就把请求发送过去
    5) 服务器接收到请求，就开始处理，结果是服务器将响应结果发送给客户端
    6) 在响应中，先发送header信息，然后是html内容
    7) HTML通过网络传输到客户端浏览器后，浏览器就开始加载页面内容，开始呈现。
        学院说法：根据html嵌套关系，得到树形的DOM树，根据出现的样式构建Style Object，结合DOM树和Style Object reflow得到Render Tree，然后通过图形API绘制出来。接下去就是loop:dom和style改变触发事件->reflow->repaint

        根据html的树形结构顺序解析文档，所有组件（外部的javascript、css、image等）无预加载，只有被解析到的时候才会加载解析。
        边解析边更新DOM树和Style Object且重新绘制页面。
        网页解析是单线程的，JavaScript的执行会阻塞网页的解析。
        image、flash等组件的加载不会阻塞网页的解析。javaScript load时不会阻塞页面解析，执行时阻塞页面解析。
        超时或者长时间加载的组件不会阻塞页面解析，javascript会因为顺序执行而阻塞之后的代码。

        产生的内容是流式传递，俗话说就是一点点传输，直到html文本传输完成，此时html里边的资源还没有加载，只是页面的html骨架加载完成了。
        浏览器这边收到html内容后开始解析html, 而且是从上到下进行解析的: 先解析html标记，然后head, 然后解析body.
        在解析过程之后，如果遇到要去加载的资源标记，例如<script>, <img>等， 此时浏览器就再次发送请求，获取资源。
        一步步，最后一只把整个页面全部解析完成， 资源加载完成，展示在用户眼前。

    客户端输入请求链接 --> DNS解析 --> 三次握手建立TCP连接 --> 发送请求  --> 服务器响应 --> 解析DOM
